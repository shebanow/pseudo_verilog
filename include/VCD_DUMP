    // VCD header definition method
    void vcd_definition(vcd::writer& vcd_writer, const bool define_clock = false) const {
        // enter new scope for module "m"
        vcd_writer.emit_scope(name());

        // define clock
        if (define_clock)
            vcd_writer.emit_vcd_clock_ID();

        // TODO: cannot call into wires or registers.
        // dump local wires
        // UMM_pair_t<const Module*, const WireBase*> module_range = wireInstanceDB.find_all_lr(this);
        // for (UMM_iter_t<const Module*, const WireBase*> it = module_range.first; it != module_range.second; it++)
        for (std::set<const ::WireBase*>::iterator w_it = wireInstanceList.begin(); w_it != wireInstanceList.end(); w_it++)
            const_cast<WireBase*>(*w_it)->vcd_definition();

        // TODO: cannot call into wires or registers.
        // dump local registers
        for (std::set<const ::RegisterBase*>::iterator r_it = registerInstanceList.begin(); r_it != registerInstanceList.end(); r_it++)
            const_cast<RegisterBase*>(*r_it)->vcd_definition();

        // recursively dump any submodules
        UMM_pair_t<const Module*, const Module*> module_range = moduleInstanceDB.find_all_lr(this);
        for (UMM_iter_t<const Module*, const Module*> it = module_range.first; it != module_range.second; it++)
            const_cast<Module*>(it->second)->vcd_definition(false);
            
        // exit current scope
        vcd_writer.emit_upscope();
    }

    // TODO: similar issues like vcd_definition, but perhaps a little worse. In this case, we need to have state dumped
    // off wires and regs, but again, we don't know any class structure yet. More and more, I wonder if the VCD class should 
    // do this (if we move the inclusion of pv_vcd.h to after wires and registers). at that point, we could make
    // the writer class a friend of modules/wires/registers and let it dump the header and value updates.

    // VCD dumpvars
    void vcd_dumpvars() const {
        // dump local wires
        for (std::set<const ::WireBase*>::iterator w_it = wireInstanceList.begin(); w_it != wireInstanceList.end(); w_it++)
            const_cast<WireBase*>(*w_it)->vcd_dumpvars();

        // dump local registers
        for (std::set<const ::RegisterBase*>::iterator r_it = registerInstanceList.begin(); r_it != registerInstanceList.end(); r_it++)
            const_cast<RegisterBase*>(*r_it)->vcd_dumpvars();

        // recursively dump any submodules
        for (std::set<const ::Module*>::iterator m_it = moduleInstanceList.begin(); m_it != moduleInstanceList.end(); m_it++) 
            const_cast<Module*>(*m_it)->vcd_dumpvars();
    }

    // VCD dumpon
    void vcd_dumpon() const {
        // dump local wires
        for (std::set<const ::WireBase*>::iterator w_it = wireInstanceList.begin(); w_it != wireInstanceList.end(); w_it++)
            const_cast<WireBase*>(*w_it)->vcd_dumpon();

        // dump local registers
        for (std::set<const ::RegisterBase*>::iterator r_it = registerInstanceList.begin(); r_it != registerInstanceList.end(); r_it++)
            const_cast<RegisterBase*>(*r_it)->vcd_dumpon();

        // recursively dump any submodules
        for (std::set<const ::Module*>::iterator m_it = moduleInstanceList.begin(); m_it != moduleInstanceList.end(); m_it++) 
            const_cast<Module*>(*m_it)->vcd_dumpon();
    }

    // VCD dumpoff
    void vcd_dumpoff() const {
        // dump local wires
        for (std::set<const ::WireBase*>::iterator w_it = wireInstanceList.begin(); w_it != wireInstanceList.end(); w_it++)
            const_cast<WireBase*>(*w_it)->vcd_dumpoff();

        // dump local registers
        for (std::set<const ::RegisterBase*>::iterator r_it = registerInstanceList.begin(); r_it != registerInstanceList.end(); r_it++)
            const_cast<RegisterBase*>(*r_it)->vcd_dumpoff();

        // recursively dump any submodules
        for (std::set<const ::Module*>::iterator m_it = moduleInstanceList.begin(); m_it != moduleInstanceList.end(); m_it++) 
            const_cast<Module*>(*m_it)->vcd_dumpoff();
    }

